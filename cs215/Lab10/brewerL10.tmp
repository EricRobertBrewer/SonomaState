#ifndef LLIST2_TMP
#define LLIST2_TMP

#include<iostream>
using namespace std;

template<class LT> class LList2;

template<class LT> ostream & operator << (ostream & outs, const LList2<LT> & L);

template<class LT>
class LList2
{
 private:
  class LNode
  {
   public:	
    LNode();
    LT data;
    LNode * next;
    LNode * prev;
  };

 public:
  LList2();
  LList2(const LList2 & other);
  ~LList2();
  LList2 & operator = (const LList2 & other);
  bool operator == (const LList2 & other);
  int Size() const;
  friend ostream & operator << <> (ostream & outs, const LList2<LT> & L);
  bool InsertFirst(const LT & value);
  bool InsertLast(const LT & value);
  bool DeleteFirst();
  bool DeleteLast();			       
  void Forward(void function(const LT & param));
  void Backward(void function(const LT & param));

 private:
  LNode * first;
  LNode * last;
  int size;
};

template<class LT>
LList2<LT>::LNode::LNode()
{
  //data = 0;
  next = NULL;
  prev = NULL;
}

template<class LT>
LList2<LT>::LList2()
{
  first = NULL;
  last = NULL;
  size = 0;
}

template<class LT>
LList2<LT>::LList2 (const LList2 & other)
{
  first = NULL;
  size = 0;
  for (LNode * n = other.first; n != NULL; n = n->next)
    InsertLast (n->data);
}

template<class LT>
LList2<LT>::~LList2 ()
{
  while (first!=NULL)
    DeleteFirst();
}

template<class LT>
LList2<LT> & LList2<LT>::operator = (const LList2 & other)
{
  if (this == &other)
    return * this;
  while (first)
    DeleteFirst();
  for (LNode * n = other.first; n != NULL; n = n->next)
    InsertLast (n->data);
  return * this;
}

template<class LT>
bool LList2<LT>::operator == (const LList2 & other)
{
  if (size != other.size)
    return false;
  LNode * n = first;
  LNode * m = other.first;
  while (n != NULL)
    {
      if (n->data != m->data)
	return false;
      n = n->next;
      m = m->next;
    }
  return true;
}

template<class LT>
int LList2<LT>::Size () const
{
  return size;
}

template<class LT>
ostream & operator << (ostream & outs, const LList2<LT> & L)
{
  if (L.first == NULL)
    return outs;
  outs << L.first->data;
  for (typename LList2<LT>::LNode * n = L.first->next; n != NULL; n = n->next)
    outs << ' ' << n->data;
  return outs;
}

template<class LT>
bool LList2<LT>::InsertFirst(const LT & value)
{
  LNode * np = new LNode;
  if(np == NULL)
    return false;
  np->data = value;
  if(size == 0)
  {
    first = np;
    last = np;
  }
  else
  {    
    first->prev = np;
    np->next = first;
    first = np;
  }
  size++;
  return true;
}

template<class LT>
bool LList2<LT>::InsertLast(const LT & value)
{
  if(size == 0)
    return InsertFirst(value);
  LNode * np = new LNode;
  if(np == NULL)
    return false;
  np->data = value;
  last->next = np;
  np->prev = last;
  last = np;
  size++;
  return true;
}

template<class LT>
bool LList2<LT>::DeleteFirst()
{
  if (size == 0)
    return false;
  if (size == 1)
  {
    LNode * np = first;
    delete np;
    first = NULL;
    last = NULL;
  }
  if (size > 1)
  {
    LNode * np = first;  
    first = first->next;
    first->prev = NULL;
    delete np;
  }
  size--;
  return true;
}

template<class LT>
bool LList2<LT>::DeleteLast()
{
  if (size == 0)
    return false;
  if (size == 1)
    return DeleteFirst();
  LNode * np = last;
  last = last->prev;
  last->next = NULL;
  delete np;
  size--;
  return true;
}

template<class LT>
void LList2<LT>::Forward(void function(const LT & param))
{
  for(LNode * n = first; n; n = n->next)
    function(n->data);
}

template<class LT>
void LList2<LT>::Backward(void function(const LT & param))
{
  for(LNode * n = last; n; n = n->prev)
    function (n->data);
}
#endif