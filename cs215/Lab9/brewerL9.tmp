#ifndef LLIST_TMP
#define LLIST_TMP

#include<iostream>
using namespace std;

template<class LT> class LList;

template<class LT> ostream & operator << (ostream & outs, const LList<LT> & L);

template<class LT>
class LList
{
 private:
  struct LNode
  {
    LNode();
    LT data;
    LNode * next;
  };

 public:
  LList();
  LList(const LList & other);
  ~LList();
  LList & operator = (const LList & other);
  bool operator == (const LList & other);
  int Size() const;
  friend ostream & operator << <> (ostream & outs, const LList<LT> & L);
  bool InsertFirst(const LT & value);
  bool InsertLast(const LT & value);
  bool DeleteFirst();
  bool DeleteLast();			       

 private:
  LNode * first;
  int size;
};

template<class LT>
LList<LT>::LNode::LNode()
{
  //data = 0;
  next = NULL;
}

template<class LT>
LList<LT>::LList()
{
  first = NULL;
  size = 0;
}

template<class LT>
LList<LT>::LList (const LList & other)
{
  first = NULL;
  size = 0;
  for (LNode * n = other.first; n != NULL; n = n->next)
    InsertLast (n->data);
}

template<class LT>
LList<LT>::~LList ()
{
  while (first)
    DeleteFirst();
}

template<class LT>
LList<LT> & LList<LT>::operator = (const LList & other)
{
  if (this == &other)
    return * this;
  while (first)
    DeleteFirst();
  for (LNode * n = other.first; n != NULL; n = n->next)
    InsertLast (n->data);
  return * this;
}

template<class LT>
bool LList<LT>::operator == (const LList & other)
{
  if (size != other.size)
    return false;
  LNode * n = first;
  LNode * m = other.first;
  while (n != NULL)
    {
      if (n->data != m->data)
	return false;
      n = n->next;
      m = m->next;
    }
  return true;
}

template<class LT>
int LList<LT>::Size () const
{
  return size;
}

template<class LT>
ostream & operator << (ostream & outs, const LList<LT> & L)
{
  if (L.first == NULL)
    return outs;
  outs << L.first->data;
  for (typename LList<LT>::LNode * n = L.first->next; n != NULL; n = n->next)
    outs << ' ' << n->data;
  return outs;
}

template<class LT>
bool LList<LT>::InsertFirst(const LT & value)
{
  LNode * np = new LNode;
  if(np == NULL)
    return false;
  np->data = value;
  np->next = first;
  first = np;
  size++;
  return true;
}

template<class LT>
bool LList<LT>::InsertLast(const LT & value)
{
  if (size == 0)
    return InsertFirst(value);
  LNode * np = new LNode;
  if (np == NULL)
    return false;
  np->data = value;
  LNode * last;
  for(last = first; last->next !=NULL; last = last->next);
  last->next = np;
  size++;
  return true;
}

template<class LT>
bool LList<LT>::DeleteFirst()
{
  if (first == NULL)
    return false;
  LNode * np = first;
  first = first->next;
  delete np;
  size--;
  return true;
}

template<class LT>
bool LList<LT>::DeleteLast()
{
  if (first == NULL)
    return false;
  if (size == 1)
    return DeleteFirst();
  LNode * last = new LNode;
  for(last = first; last->next->next !=NULL; last = last->next);
  last->next = NULL;
  size--;
  return true;
}

#endif